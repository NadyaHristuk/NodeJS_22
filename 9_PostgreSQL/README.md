   # PostgreSQL и ORM Sequelize
https://www.youtube.com/watch?v=BuJj4LCWP_4 - руководство как подключить облачный PostgreSQL
База данных
Реляционные базы данных
PostgreSQL
Connection Pool
Object-Relational Mapping (ORM)
Sequelize
1. База данных
База данных — это информационная модель, позволяющая упорядоченно хранить данные о группе объектов, обладающих одинаковым набором свойств.

Создавая базу данных, пользователь стремится упорядочить информацию по различным признакам и быстро производить выборку с произвольным сочетанием признаков. При этом очень важно выбрать правильную модель данных. Модель данных — это формализованное представление основных категорий восприятия реального мира, представленных его объектами, связями, свойствами, а также их взаимодействиями. Информация в базах данных хранится в упорядоченном виде. Группу связанных между собой элементов данных называют обычно записью.

В качестве примера простейших БД можно назвать телефонный справочник, расписание движения поездов, сведения о сотрудниках предприятия, список цен на товары, алфавитный или предметный каталог книг в библиотеке, словарь иностранных слов, результаты сдачи сессии студентами, каталог видеозаписей, список кулинарных рецептов, каталог товаров (прайслист).

Главное достоинство электронных БД — возможность быстрого поиска и отбора информации, а также простая генерация (создание) отчета по заданной форме. Например, по номерам зачеток легко определить фамилии студентов или по фамилии писателя составить список его произведений.

В современных условиях наиболее широкое применение в разработке программного обеспечения сыскали реляционные и нереляционные базы данных. В последнее время появилось много нереляционных баз данных. Это говорит о том, что если вам нужна практически неограниченная масштабируемость по требованию, вам нужна нереляционная база данных.

Но стоит также отметить одно важное обстоятельство — реляционные базы данных существуют уже около 30 лет. За это время вспыхивало несколько революций, которые должны были положить конец реляционным хранилищам. Конечно, ни одна из этих революций не состоялась, и одна из них ни на йоту не поколебала позиции реляционных БД.
2. Реляционные базы данных
Реляционная база данных — это совокупность отношений, содержащих всю информацию, которая должна храниться в БД. Однако пользователи могут воспринимать такую базу данных как совокупность таблиц. Следует отметить:

Каждая таблица состоит из однотипных строк и имеет уникальное имя. Строки имеют фиксированное число полей (столбцов) и значений (множественные поля и повторяющиеся группы недопустимы). Иначе говоря, в каждой позиции таблицы на пересечении строки и столбца всегда имеется в точности одно значение или ничего.

Строки таблицы обязательно отличаются друг от друга хотя бы единственным значением, что позволяет однозначно идентифицировать любую строку такой таблицы.

Столбцам таблицы однозначно присваиваются имена, и в каждом из них размещаются однородные значения данных (даты, фамилии, целые числа или денежные суммы).

Говоря о реляционных базах данных нельзя не остановиться на двух очень важных моментах:

SQL (structured query language, язык структурированных запросов) — это язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

СУБД (система управления базой данных) — пакет программ, обеспечивающих создание БД и организацию данных. СУБД позволяют вводить, отбирать и редактировать данные. СУБД предоставляют средства для извлечения данных по определенному критерию (требованию, правилу). СУБД дают возможность конечным пользователям осуществлять непосредственное управление данными, а программистам и системным аналитикам быстро разрабатывать более совершенные программные средства их обработки.
Вернемся к самой базе данных. Как мы уже говорили, реляционная база данных представляет собой набор таблиц (сущностей). Таблицы состоят из колонок и строк (кортежей). Внутри таблиц могут быть определены ограничения, между таблицами существуют отношения. При помощи SQL можно выполнять запросы, которые возвращают наборы данных, получаемых из одной или нескольких таблиц. В рамках одного запроса данные получаются из нескольких таблиц путем их соединения (JOIN), чаще всего для соединения используются те же колонки, которые определяют отношения между таблицами.

Стоит также отметить, что реляционные базы данных невероятно сложны внутри. Например, простой SELECT запрос может иметь сотни потенциальных путей выполнения, которые оптимизатор оценит непосредственно во время выполнения запроса. Все это скрыто от пользователей, однако внутри система управления базой данных создает план выполнения, основывающийся на вещах вроде алгоритмов оценки стоимости и наилучшим образом отвечающий запросу.

Из этого следует, что хотя реляционные базы данных и обеспечивают наилучшую смесь простоты, устойчивости, гибкости, производительности, масштабируемости и совместимости, их показатели по каждому из этих пунктов не обязательно выше, чем у аналогичных систем, ориентированных на какую-то одну особенность. Это не являлось большой проблемой, поскольку всеобщее доминирование реляционных систем управления базами данных перевешивало какие-либо недочеты. Тем не менее, если обычные реляционные базы данных не отвечали потребностям, всегда существовали альтернативы.

Реляционная модель баз данных гарантирует атомарность, согласованность, изолированность, надежность (ACID) операции манипулирования данными, что мешает обеспечить высокую доступность и быстродействие в случае, когда данные распределены по нескольким сервисам из-за их значительного объема. Для решения проблемы обеспечения высокого быстродействия при распределенном способе хранения информации была разработана специальная разновидность баз данных NoSQL (Not only SQL). Более подробно они будут рассмотрены в следующей лекции.
3. PostgreSQL

PostgreSQL — это объектно-реляционная система управления базами данных, основанная на POSTGRES, Version 4.2 — программе, разработанной на факультете компьютерных наук Калифорнийского университета в Беркли. В POSTGRES появилось множество новшеств, которые были реализованы в некоторых коммерческих системах управления базами данных гораздо позднее. Она поддерживает большую часть стандарта SQL и предлагает множество современных функций:

сложные запросы
внешние ключи
триггеры
изменяемые представления
транзакционная целостность
многоверсионность
Кроме того, пользователи могут всячески расширять возможности PostgreSQL, например создавая свои типы данных, функции, операторы, агрегатные функции, методы индексирования, процедурные языки. А благодаря свободной лицензии, PostgreSQL разрешается бесплатно использовать, изменять и распространять всем и для любых целей — личных, коммерческих или учебных.

Скачать и установить PostgreSQL вы можете с официального сайта - https://www.postgresql.org/download/.

Также рекомендуется скачать и установить бесплатный инструмент-интерфейс для работы с PostgreSQL — PgAdmin (вы можете воспользоваться любым другим инструментом, но в рамках курса будет рассмотрен именно этот) —https://www.pgadmin.org/download/. После установки вам потребуется ввести пароль, запомните его, он пригодится для подключения к локальному серверу.

Так же для работы связки node.js и postgreSQL вам понадобится устанавливаемый модуль pg (документация https://node-postgres.com/).
npm install --save pg
Теперь вы можете настроить подключение к базе данных.
const { Client } = require('pg');

	const db = new Client({
	  user: 'postgres',
	  host: 'localhost',
	  database: 'webinar',
	  password: '1234',
	  port: 5432
	});
	db.connect();

	db.query('SELECT NOW()', (err, res) => {
	  console.log(err, res);
	  db.end();
	});
Тот же пример с использованием синтаксиса async\await.
const { Client } = require('pg')
const db = new Client({
    user: 'postgres',
    host: 'localhost',
    database: 'webinar',
    password: '1234',
    port: 5432,
});
async function connect() {
    await db.connect();
    const res = await db.query('SELECT NOW()');
    await db.end();
};

connect();

Хорошим тоном считается вынесение параметров подключения к базе данных в отдельный конфигурационный файл. Этот момент мы рассмотрим немного позже.

Модуль pg предоставляет нам не самое большое API для взаимодействия с базой данных, но вполне достаточное для того, чтобы реализовывать вещи любой сложности за счет гибкости языка SQL.

Таким способом мы можем создать Connection Pool, который выгодно отличается от классического подключения (подробнее чуть ниже).
const { Pool } = require('pg');
	const pool = new Pool();
Классическое подключение. 
const { Client } = require('pg');
	const client = new Client();
Клиент и пулл обладают практически идентичным API. Они могут реагировать на некоторые события, например, подключение\отключение пользователей, обрабатывать ошибки т т.д. Так же они оба обладают методом query — основным методом модуля, который принимает строку с SQL-кодом. С помощью этого метода и строится практически вся работа с базой данных.


Также стоит отметить, что в коде выше в переменной res содержится результат работы метода query, которая возвращает новый экземпляр класса pg.Result
4. Connection Pool
Подавляющее большинство современных веб-приложений использует базы данных для хранения информации. Приложение может обмениваться информацией с базой данных, используя соединение (database connection). Если создавать при каждом обращении к БД, получается проигрыш во времени: выполнение транзакции может занять несколько миллисекунд, в то время как на создание соединения может уйти до нескольких секунд.

С другой стороны, можно создать одно-единственное соединение (например, используя шаблон "Singleton") и обращаться к базе данных только через него. Но это решение чревато проблемами, в случае высокой нагрузки: если одновременно сто пользователей попытается получить доступ к базе данных используя одно соединение, образуется очередь, что также пагубно сказывается на производительности приложения.

Database Connection Pool (dbcp) — это способ решения изложенной выше проблемы. Он подразумевает, что в нашем распоряжении имеется некоторый набор («пул») соединений к базе данных. Когда новый пользователь запрашивает доступ к БД, ему выдаётся уже открытое соединение из этого пула. Если все открытые соединения уже заняты, создаётся новое. Как только пользователь освобождает одно из уже существующих соединений, оно становится доступно для других пользователей. Если соединение долго не используется, оно закрывается.
5. Object-Relational Mapping (ORM).
Object-Relational Mapping (ORM, объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

Перед ORM стоит одна очень важная задача — необходимо обеспечить работу с данными в терминах классов, а не таблиц данных и в то же время, преобразовать термины и данные классов в данные, пригодные для хранения в системах управления базами данных. Необходимо также обеспечить интерфейс для CRUD-операций над данными. В общем, необходимо избавиться от необходимости писать SQL-код для взаимодействия в системах управления базами данных. Грубо говоря, ORM позволяют работать с данными, как с обычным javascript-объектом, у которого есть собственные свойства и методы для взаимодействия с базами данных.

Некоторые реализации ORM автоматически синхронизируют загруженные в память объекты с базой данных. Для того чтобы это было возможным, после создания объект-в-SQL-преобразующего SQL-запроса (класса, реализующего связь с DB) полученные данные копируются в поля объекта, как во всех других реализациях ORM. После этого объект должен следить за изменениями этих значений и записывать их в базу данных.

С точки зрения программиста система должна выглядеть как постоянное хранилище объектов. Он может просто создавать объекты и работать с ними как обычно, а они автоматически будут сохраняться в реляционной базе данных.

На практике всё не так просто и очевидно. Все системы ORM обычно проявляют себя в том или ином виде, уменьшая в некотором роде возможность игнорирования базы данных. Более того, слой транзакций может быть медленным и неэффективным (особенно в терминах сгенерированного SQL). Все это может привести к тому, что программы будут работать медленнее и использовать больше памяти, чем программы, написанные «вручную».

Но ORM избавляет программиста от написания большого количества кода, часто однообразного и подверженного ошибкам, тем самым значительно повышая скорость разработки. Кроме того, большинство современных реализаций ORM позволяют программисту при необходимости самому жёстко задать код SQL-запросов, который будет использоваться при тех или иных действиях (сохранение в базу данных, загрузка, поиск и т. д.) с постоянным объектом.
6. Sequelize

Библиотека Sequelize — это Node.js ORM система для работы с такими базами данных, как PostgreSQL, MySQL, SQLite и MSSQL. Давайте начнем работать с Sequelize. Нам нужно установить данную библиотеку.
npm install --save sequelize
После этого нужно установить одну из библиотек. Например, если вы хотите работать с PostgreSQL, то нужно установить pg-hstore. PostgreSQL, pg можно не устанавливать вновь, если он уже был установлен в результате вашей работы.
npm install --save pg pg-hstore 
Дополнительно приведен пример установки модулей для других реляционных баз данных.
npm install --save mysql2  // MySQL
npm install --save sqlite3  // SQLite
npm install --save tedious  // MSSQL
Далее необходимо подключиться к базе данных., где database — имя вашей базы, username и password — соответственно, имя вашего пользователя в pgAdmin, host — адрес подключения, dialect — система управления базой данных, с которой вы работаете (например, если вы работаете с PostgreSQL, то нужно указать postgres) и pool — соответственно, параметры для connection pool.
const Sequelize = require('sequelize');
	const sequelize = new Sequelize('database', 'username', 'password', {
	  host: 'localhost',
	  dialect: 'postgres',
	  pool: {
	    max: 5,
	    min: 0,
	    idle: 10000
	  }
	});
Существуют и другие параметры для подключения, в данном случае, можно обойтись и без них. Для более детального изучения этого вопроса обратитесь к документации.

В константе (переменной) sequelize содержится экземпляр соединения, созданный с помощью импортированного конструктора Sequelize, и мы можем с ним работать. Sequelize имеет функцию (метод) authenticate, с помощью которого можно проверить состояние соединения.
sequelize
  	.authenticate()
	  .then(() => {
	    console.log('Соединение установлено.');
 	 })
	  .catch(err => {
 	   console.error('Ошибка соединения:', err);
	  });
После настройки подключения мы можем создавать необходимые нам модели. Модель представляет собой схематичное отображение будущей строки таблицы в виде javascript-объекта, где каждое свойство строго типизировано. Все возможные типы (а их достаточно много), вы можете посмотреть в документации.

Кроме свойств, вы также можете создавать для ваших моделей новые методы, например, для конкатенации полного имени, или приведения даты в необходимый формат с последующей записью в базу данных. Хорошим тоном считается создание моделей в отдельной папке (по аналогии с маршрутами), где под каждую модель определен отдельный файл.
Модель пользователя (файл ./models/User.js)
module.exports = (sequelize, DataTypes) => {
  	  const User = sequelize.define("user", {
    	      name: {
	        type: DataTypes.STRING
	      }
	    });
	  return User ;
	};
Остается только подключить модель к экземпляру соединения, и тогда можно будет воспользоваться встроенными методами модели. Существуют несколько подходов к подключению, одним из наиболее оптимальных считается этот (в основной файл необходимо подключить модули fs и path, так как они понадобятся для поиска моделей):
fs.readdirSync(‘./models’)
 .filter(function (file) {
   return (file.indexOf(‘.’) !== 0) && (file !== ‘index.js’)
 })
 .forEach(function (file) {
   sequelize.import(path.join(__dirname, ‘./models’, file))
 })

Object.keys(sequelize.models).forEach(function (modelName) {
 if (‘associate’ in sequelize.models[modelName]) {
   sequelize.models[modelName].associate(sequelize)
 }
})

В данном коде мы просматриваем директорию с моделями, и если они есть, то импортируем их в наш экземпляр соединения, затем просматриваем каждую модель в отдельности на предмет наличия у нее метода associate, который позволяет строить связи между моделями, и, в случае его наличия, вызываем его для создания связей между моделями.

Типы связей, поддерживаемых ORM Sequelize:
One-to-One (Один к одному) — это означает, что каждой записи в одной таблице соответствует не более одной записи в связанной таблице. Этот вид связи встречается довольно редко. В основном, в тех случаях, когда часть информации об объекте либо редко используется, либо является конфиденциальной (такая информация хранится в отдельной таблице, которая защищена от несанкционированного доступа). Например, анкетные данные студента (ФИО, факультет, курс, группа, дата рождения и т.п.) могут храниться в одной таблице БД, а сведения о родителях этого студента – в другой, т.к. эта информация используется достаточно редко и может быть отделена от основной.

One-to-Many (Один ко многим) — при таком типе связи каждой записи в одной таблице соответствует одна или более записей в связанной таблице. Для реализации такого отношения используются две таблицы. Одна из них представляет сторону «один», другая — сторону «много». Например, нужно иметь информацию о студентах и результатах сдачи ими экзаменов (дата сдачи, предмет, оценка и т.д.). Если все это хранить в одной таблице, то ее объем неоправданно возрастет, т.к. в ней для каждой записи об очередном экзамене должны повторяться все анкетные сведения о студенте. Поскольку Студент и Экзамены — это разные сущности, то и атрибуты их должны храниться в разных таблицах. Но эти сущности связаны между собой, т.к. экзамены сдает определенный студент. Причем один студент может сдавать несколько экзаменов, т.е. налицо тип отношения «один-ко-многим».

Belongs-to-Many (Относится ко многим) — При этом типе связи множеству записей в одной таблице соответствует множество записей в связанной таблице.
Давайте создадим новую модель, например, модель подписки на абстрактную рассылку.
module.exports = (sequelize, DataTypes) => {
  	  const Subscription= sequelize.define("subscription", {
    	      name: {
	        type: DataTypes.STRING
	      }
	    });
	  return Subscription;
	};
Как видите, модели достаточно простые, но этого хватит, чтобы установить между ними связь. Для этого перед тем, как вернуть объект модели, нам необходимо расширить его методом associate для создания связи.
Представим, что пользователь может иметь только одну подписку, в таком случае модель пользователя будет выглядеть так:
module.exports = (sequelize, DataTypes) => {
  	  const User = sequelize.define("user", {
    	      name: {
	        type: DataTypes.STRING
	      }
	    });
   User.associate = function (models) {
        		User.belongsTo(models.subscription);
    	   };
	  return User ;
	};
Для того, чтобы дать пользователю возможность иметь несколько подписок, нам достаточно заменить тип связи:
User.associate = function (models) {
        		User.hasMany(models.subscription);
    	 };
Для того, чтобы взаимодействовать с данными, не обязательно писать
SQL-запросы (хотя такая возможность в ORM присутствует). Взаимодействие
с данными строится по CRUD(create, read, update, delete)-шаблону, и у каждой модели имеются соответствующие методы.
Например, вызов
 User.findAll();
Эквивалентен чтению, будут прочитаны и переданы все записи в базе данных, соответствующие модели пользователя (т.е. занесенные в таблицу пользователей, если абстрагироваться от использования ORM).

Точно так же можно взаимодействовать с базой данных в остальных случаях — при создании, обновлении и удалении. Под каждый случай имеется соответствующий метод, который принимает набор параметров (как правило, это отличительные признаки объекта (т.е. строки таблицы), по которым будет произведена выборка и дальнейшее действие. Вы можете редактировать или удалять как одну, так и несколько моделей сразу, главное - корректно переданные параметры для выборки.

Параметры могут принимать любое свойство объекта. Лично я рекомендую как можно чаще использовать автоматически создаваемый __id, а не какие-либо другие свойства, т.к. высока вероятность их повторения или переопределения.
Для создания записи используется метод create, который принимает объект с данными (он должен соответствовать модели):
db.models.user.create(data, {
            	include: [{
            	    all: true
         	   }]
        	});
Параметр include позволяет связать все необходимые модели. Вы можете связывать только некоторые модели, а можете не связывать их вовсе. Для обновления и удаления алгоритм немного сложнее — сначала вам необходимо найти конкретную запись (data в данном случае — id изменяемой записи, а newData — новые данные модели).
let findedUser = await sequelize.models.user.findOne({ where: { id: data } });
findedUser.update(newData); // Обновление
findedUser.destroy(); // Удаление
Полезные ссылки
https://www.postgresql.org/ — официальный сайт PostrgeSQL.
https://node-postgres.com/ — документация модуля pg для
работы node.js вместе с postgreSQL.
https://www.pgadmin.org/ — официальный сайт PgAdmin.
http://docs.sequelizejs.com/ — официальный сайт ORM Sequeilize.